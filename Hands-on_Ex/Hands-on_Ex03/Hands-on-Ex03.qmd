# Loading packages and data

```{r}
##install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
library(maptools)

pacman::p_load(sf, raster, spatstat, tmap,tidyverse)
```

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
```

## Importing Geospatial Data into R

```{r}
mpsz <- st_read(dsn = "../data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

```{r}
mpszNoSea <- st_read(dsn = "../data/geospatial", 
                layer = "MP14_SUBZONE_NO_SEA_PL")
```

# COASTAL AREA OF COUNTRY

```{r}


simplified_country <- st_simplify(mpsz, preserveTopology = TRUE)

sg_sf <- st_union(simplified_country)

plot(sg_sf, col = "lightblue", main = "Sea Area")


```

```{r}
#tm_shape(sg_sf)+tm_borders()
```

## 4.4.2 Mapping the geospatial data sets

```{r}
#tmap_mode('view')
#tm_shape(childcare_sf)+
#  tm_dots()
```

# 4.5 Geospatial Data wrangling ##4.5.1 Converting sf data frames to sp’s Spatial\* class

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz)
sg <- as_Spatial(sg_sf)
```

```{r}

childcare
```

## 4.5.2 Converting the Spatial\* class into generic sp format

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
childcare_sp
sg_sp
```

##  4.5.3 Converting the generic sp format into spatstat’s ppp format

```{r}
class(childcare_sp)

```

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

```{r}
plot(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

## 4.5.4 Handling duplicated points

```{r}
any(duplicated(childcare_ppp))
multiplicity(childcare_ppp)
sum(multiplicity(childcare_ppp) > 1)
```

```{r}
#tmap_mode('view')
#tm_shape(childcare) +
#  tm_dots(alpha=0.4, 
 #         size=0.05)
```

## TO REMOVE DUPPLICATES

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
any(duplicated(childcare_ppp_jit))
```

## 4.5.5 Creating owin object

```{r}
sg_owin <- as(sg_sp, "owin")
```

```{r}
plot(sg_owin)
```

## 4.5.6 Combining point events object and owin object

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
summary(childcareSG_ppp)
```

```{r}
plot(childcareSG_ppp)
```

# 4.6 First-order Spatial Point Patterns Analysis ##4.6.1 Kernel Density Estimation ##4.6.1.1 Computing kernel density estimation using automatic bandwidth selection method

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_childcareSG_bw)
```

Compute bandwidth

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

## 4.6.1.2 Rescalling KDE values In the code chunk below, rescale() is used to covert the unit of measurement from meter to kilometer.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

Rerun density

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

## 4.6.2 Working with different automatic badwidth methods

```{r}
 bw.CvL(childcareSG_ppp.km)
bw.scott(childcareSG_ppp.km)
bw.ppl(childcareSG_ppp.km)
bw.diggle(childcareSG_ppp.km)
```

Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

## 4.6.3 Working with different kernel methods The code chunk below will be used to compute three more kernel density estimations by using these three kernel function.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

# 4.7 Fixed and Adaptive KDE ##4.7.1 Computing KDE by using fixed bandwidth

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

## 4.7.2 Computing KDE by using adaptive bandwidth

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

Comparing fixed vs adaptive

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")

```

## 4.7.3 Converting KDE output into grid object. The result is the same, we just convert it so that it is suitable for mapping purposes

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)

```
 
## 4.7.3.1 Converting gridded output into raster

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Looking at property of raster layer

```{r}
kde_childcareSG_bw_raster
```

## 4.7.3.2 Assigning projection systems

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

## 4.7.4 Visualising the output in tmap

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

## 4.7.5 Comparing Spatial Point Patterns using KDE 4.7.5.1 Extracting study area

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

Covert to SP format

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

## 4.7.5.3 Creating owin object

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

## 4.7.5.4 Combining childcare points and the study area By using the code chunk below, we are able to extract childcare that is within the specific region to do our analysis later on.

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Next, rescale() function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
childcare_pg_ppp_km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp_km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp_km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp_km = rescale(childcare_jw_ppp, 1000, "km")
```

The code chunk below is used to plot these four study areas and the locations of the childcare centres.

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp_km, main="Punggol")
plot(childcare_tm_ppp_km, main="Tampines")
plot(childcare_ck_ppp_km, main="Choa Chu Kang")
plot(childcare_jw_ppp_km, main="Jurong West")
```

## 4.7.5.5 Computing KDE (dw.diggle)

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

## 4.7.5.6 Computing fixed bandwidth KDE

```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp_km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp_km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp_km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp_km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

# 4.8 Nearest Neighbour Analysis The test hypotheses are:

Ho = The distribution of childcare services are randomly distributed.

H1= The distribution of childcare services are not randomly distributed.

The 95% confident interval will be used.

## 4.8.1 Testing spatial point patterns using Clark and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

## 4.8.2 Clark and Evans Test: Choa Chu Kang planning area In the code chunk below, clarkevans.test() of spatstat is used to performs Clark-Evans test of aggregation for childcare centre in Choa Chu Kang planning area.

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

## 4.8.3 Clark and Evans Test: Tampines planning area

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

# 5  2nd Order Spatial Point Patterns Analysis Methods

## 5.7 Analysing Spatial Point Process Using G-Function
## 5.7.1 Choa Chu Kang planning area
# 5.7.1.1 Computing G-function estimation
The code chunk below is used to compute G-function using Gest() of spatat package.
```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```
# 5.7.1.2 Performing Complete Spatial Randomness Tes

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
plot(G_CK.csr)
```

# 5.7.2.2 Performing Complete Spatial Randomness Test
To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.


```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

```{r}
plot(G_tm.csr)
  

```

# 5.8 Analysing Spatial Point Process Using F-Function
The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape. In this section, you will learn how to compute F-function estimation by using Fest() of spatstat package. You will also learn how to perform monta carlo simulation test using envelope() of spatstat package.

## 5.8.1 Choa Chu Kang planning area
# 5.8.1.1 Computing F-function estimation
```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)

```

## 5.8.2 Performing Complete Spatial Randomness Test
```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)

```
```{r}
plot(F_CK.csr)
```

## 5.8.3 Tampines planning area
# 5.8.3.1 Computing F-function estimation
Monte Carlo test with F-fucntion
```{r}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```


# 5.8.3.2 Performing Complete Spatial Randomness Test
To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.
```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
plot(F_tm.csr)
```

# 5.9 Analysing Spatial Point Process Using K-Function
K-function measures the number of events found up to a given distance of any particular event. In this section, you will learn how to compute K-function estimates by using Kest() of spatstat package. You will also learn how to perform monta carlo simulation test using envelope() of spatstat package.

## 5.9.1 Choa Chu Kang planning area
# 5.9.1.1 Computing K-fucntion estimate
```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")

```

# 5.9.1.2 Performing Complete Spatial Randomness Test
To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.
```{r}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

## 5.9.2 Tampines planning area
# 5.9.2.1 Computing K-fucntion estimation
```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

## 5.9.2.2 Performing Complete Spatial Randomness Test
To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.

```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

# 5.10 Analysing Spatial Point Process Using L-Function
In this section, you will learn how to compute L-function estimation by using Lest() of spatstat package. You will also learn how to perform monta carlo simulation test using envelope() of spatstat package.

## 5.10.1 Choa Chu Kang planning area
### 5.10.1.1 Computing L Fucntion estimation
```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

5.10.1.2 Performing Complete Spatial Randomness Test
To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value if smaller than alpha value of 0.001.

The code chunk below is used to perform the hypothesis testing.
```{r}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

## 5.10.2 Tampines planning area
### 5.10.2.1 Computing L-fucntion estimate

```{r}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```
### 5.10.2.2 Performing Complete Spatial Randomness Test
To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

The code chunk below will be used to perform the hypothesis testing.

```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```

