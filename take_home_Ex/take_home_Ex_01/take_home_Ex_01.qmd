---
title: "Take home 1"
execute:
  error: false
  eval: false
---
# Take home ex 1

## Tasks

The specific tasks of this take-home exercise are as follows:

Using appropriate function of sf and tidyverse, preparing the following geospatial data layer in sf tibble data.frames: Grab taxi location points either by origins or destinations. Road layer within Singapore excluding outer islands. Singapore boundary layer excluding outer islands Using the extracted data, derive traditional Kernel Density Estimation layers. Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE) Using appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore. Describe the spatial patterns revealed by the kernel density maps.

# Setup

## Importing packages

```{r}
pacman::p_load(tidyverse,sf,tmap,lubridate,arrow,spNetwork,classInt,viridis,raster,spatstat)
library(maptools)
```

# 1.0 Data Wrangling

## Geospatial

## 1.1 Importing data

### Map data

```{r}
mpsz <- st_read(dsn = "../../Hands-on_Ex/data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
st_set_crs(mpsz, 3414)
```

### Road data

```{r}
roads_sf<-st_read(dsn = "data/geospatial",layer= "gis_osm_roads_free_1")
```

### Importing Grab posisi 1

```{r}
grab1 <-read_parquet("data/aspatial/GrabPosisi/part-00000-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
```

## Add grab data together Concat the data together
```{r}
#grab2 <-read_parquet("data/aspatial/GrabPosisi/part-00001-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab3 <-read_parquet("data/aspatial/GrabPosisi/part-00002-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab4 <-read_parquet("data/aspatial/GrabPosisi/part-00003-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab5 <-read_parquet("data/aspatial/GrabPosisi/part-00004-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab6 <-read_parquet("data/aspatial/GrabPosisi/part-00005-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab7 <-read_parquet("data/aspatial/GrabPosisi/part-00006-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab8 <-read_parquet("data/aspatial/GrabPosisi/part-00007-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab9 <-read_parquet("data/aspatial/GrabPosisi/part-00008-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab10 <-read_parquet("data/aspatial/GrabPosisi/part-00009-8bbff892-97d2-4011-9961-703e38972569.c000.snappy.parquet")
#grab_combined_df <- bind_rows(grab1,grab2,grab3,grab4,grab5,grab6,grab7,grab8,grab9,grab10)
```

## 1.2 Pre-processing

### Sources - Megan's journey - to check if geometries are valid

```{r}
length(which(st_is_valid(roads_sf) == FALSE))
length(which(st_is_valid(mpsz) == FALSE))
```

```{r}

mpsz <- st_make_valid(mpsz)
length(which(st_is_valid(mpsz) == FALSE))
## source: https://r-spatial.github.io/sf/reference/valid.html - make_valid
```

## 1.3 Checking Coordinate system

### Checking MPSZ

```{r}
st_crs(mpsz)
```

### Checking Roads

```{r}
st_crs(roads_sf)
```

### Making roads data into projected SVY21

```{r}
roads3414 <- st_transform(roads_sf, 
                              crs = 3414)
st_crs(roads3414)
```

## 1.4 Removing of outer islands

```{r}


sg_sf <- st_union(mpsz,by_feature = FALSE)

plot(sg_sf, col = "lightblue", main = "Sea Area")

```

Big island

```{r}
##source - https://stackoverflow.com/questions/42512431/how-to-separate-a-multipolygon-geometry-into-several-polygons-objects-after-perf

ind_poly <- st_cast(sg_sf, "POLYGON")

areas <- st_area(ind_poly)

largest_index <- which.max(areas)

largest_polygon <- ind_poly[largest_index]

plot(largest_polygon)

```

Check crs of largest / convert to SVY

```{r}
mpsz3414 <- st_transform(largest_polygon, 
                              crs = 3414)
st_crs(mpsz3414)
```
## 1.5 Getting polygons inside big island
```{r}
mpsz3414
mpsz
```
```{r}
mpsz3414
mpsz
islandPoly <- st_intersection(st_set_crs(mpsz, 3414),st_set_crs(mpsz3414, 3414))

```
```{r}
plot(islandPoly)
```

# 2.0 Aspatial Wrangling

## 2.1 Changing timestamp to correct one

```{r}
grab1$pingtimestamp <- as_datetime(grab1$pingtimestamp)
```

::: callout-note
## DIY

Write a code chunk to - Extract trip origin location - derice three new column, weekday, starting hour and day of the month - name the output tibble data.frame origin_df
:::

```{r}
origin_df <-grab1 %>% 
  group_by(trj_id)%>%
  arrange(pingtimestamp) %>%
  filter(row_number()==1) %>%
  mutate(weekday = wday(pingtimestamp,
                        label=TRUE,
                        abbr = TRUE),
         start_hr = factor(hour(pingtimestamp)),
         day = factor(mday(pingtimestamp)))
```

```{r}
# Perform a spatial join to filter roads within Singapore
#roadI <- roads3414[10]
#roads_in_singapore <- st_intersection(roadI, mpsz3414)

# Plot the roads within Singapore
#plot(roads_in_singapore)
# Simplify geometry of road data (adjust tolerance as needed)
road_data <- st_simplify(roads3414, preserveTopology = TRUE)


# Perform spatial intersection after simplification
roads_in_singapore <- st_intersection(road_data, mpsz3414)

```

## 2.2 plot map and roads to check

```{r}
tm_shape(roads_in_singapore$geometry)+tm_lines()
```


## Check class of grab data

```{r}
class(origin_df)
```

## 2.3 Converting Aspatial object to geospatial
```{r}
# Convert tibble to sf object
sf_object <- st_as_sf(origin_df, coords = c("rawlng", "rawlat"), crs = 4326) %>% st_transform(crs = 3414)
#sf_object2 <- st_as_sf(grab_combined_df, coords = c("rawlng", "rawlat"), crs = 4326) %>% st_transform(crs = 3414)

```


## We can plot the points on the map to see how it looks

```{r}
lines <- st_cast(roads_in_singapore$geometry, "MULTILINESTRING")
lines <- st_cast(lines, "LINESTRING")
```

```{r}
st_crs(sf_object)
st_crs(lines)
```

```{r}

tm_shape(lines)+tm_lines()+
  tm_shape(sf_object)+tm_dots()


```

```{r}

  tm_shape(mpsz3414)+tm_polygons()+tm_shape(sf_object)+tm_dots()


```
## 2.4 Converting grab posisi into raster ppp format
### lab way of converting aspatial to project on map

```{r}
origin_df2 <- as_Spatial(sf_object)
object_sp <- as(origin_df2, "SpatialPoints")
object_sp
object_ppp <- as(object_sp, "ppp")
object_ppp
```
## plotting ppp to see how it looks like
```{r}
plot(object_ppp)
```
## Check if lat long makes sense -> conversion is correct
```{r}
object_ppp

```
### Tm plot with spatial points + map 
```{r}
tmap_mode('view')
  tm_shape(mpsz3414)+tm_polygons()+tm_shape(object_sp)+tm_dots()
tmap_mode('plot')

```


## 2.5Handling Duplicated Points

```{r}
any(duplicated(object_ppp))
```
### Jittering duplicates away
```{r}
object_ppp_jit <- rjitter(object_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```
### Checking duplicates after jitter
```{r}
any(duplicated(object_ppp))
```
## Creating owin object
## Converting mpsz3414 to SP spatial class before converting to owin object
```{r}
mpsz3414
```


```{r}
sg_sp <- as_Spatial(mpsz3414)
sg_sp <- as(sg_sp, "SpatialPolygons")
sg_sp
object_ppp
sg_owin2 <- as(sg_sp, "owin")
sg_owin2
```
## Plotting sg owin
```{r}
plot(sg_owin2)
```
## Combine point object (grab) with sg owin 
```{r}
grabSg_ppp = object_ppp[sg_owin2]
plot(grabSg_ppp)
```

# 3.0 KDE - Kernal Density Estimations
### Grab posisi (1 dataset)
```{r}
tmap_mode('view')
tm_shape(object_sp) +
  tm_dots(alpha=0.4, 
          size=0.05)
```


## 3.1 Using automatic bandwidth selection - diggle
```{r}
kde_grab_sg <- density(grabSg_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_grab_sg)
```
## 3.1.1 Rescaling trhe values as its too small 
```{r}
grabSg_ppp.km <- rescale(grabSg_ppp, 1000, "km")
kde_grab_sg <- density(grabSg_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_grab_sg)
```
## 3.1.2 Other automatic bandwidth 
```{r}
 bw.CvL(grabSg_ppp.km)
```
```{r}
grabSg_ppp.ppl <- density(grabSg_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_grab_sg, main = "bw.diggle")
plot(grabSg_ppp.ppl, main = "bw.ppl")
```
### 3.2 Observation 
.ppl is better in showing different clusters on the map. Bw not so good, only showing those with very high intensity

## 3.3 Working with different density methods
```{r}
par(mfrow=c(2,2))
plot(density(grabSg_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(grabSg_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(grabSg_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(grabSg_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## 3.3.1 Fixed bandwith method
```{r}
kde_grabSg_800 <- density(grabSg_ppp.km, sigma=0.8, edge=TRUE, kernel="gaussian")
plot(kde_grabSg_800)
```
### 3.3.2 Findings
Using the fixed bandwith, it it easier to see / adjust the headmap to see which areas in singapore are more intense

## 3.4 Comparing regions
### 3.4.1 TOA PAYOH and TAMPINES as its the most intense regions
```{r}
mpsz2 <- as_Spatial(mpsz)
tp = mpsz2[mpsz2@data$PLN_AREA_N == "TOA PAYOH",]
tm = mpsz2[mpsz2@data$PLN_AREA_N == "TAMPINES",]
```

### 3.4.2 Plotting them out
```{r}
par(mfrow=c(2,2))
plot(tp, main = "Toa payoh")
plot(tm, main = "Tampines")

```
### 3.4.3 Converting to spatial polygons
```{r}
tm_sp = as(tm, "SpatialPolygons")
tp_sp = as(tp, "SpatialPolygons")

```

### 3.4.4 Making them owin
```{r}
tp_owin = as(tp_sp, "owin")
tm_owin = as(tm_sp, "owin")
```

### 3.4.5 Combinining
```{r}
grab_tp_ppp = object_ppp_jit[tp_owin]
grab_tm_ppp = object_ppp_jit[tm_owin]
```
### 3.4.6 Rescaling
```{r}
grab_tp_ppp.km = rescale(grab_tp_ppp, 1000, "km")
grab_tm_ppp.km = rescale(grab_tm_ppp, 1000, "km")
```
### 3.4.6 Plot
```{r}
par(mfrow=c(2,2))
plot(grab_tp_ppp.km, main="Toa Payoh")
plot(grab_tm_ppp.km, main="Tampines")
```
## 3.5 Findings

toh payoh intensity looks spread out whereas tampines one looks very clustered

## 3.6 Computing KDE for each region (automatic)
```{r}
par(mfrow=c(2,2))
plot(density(grab_tp_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Toa Payoh")
plot(density(grab_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```
## 3.7 Computing using fixed bandwith
```{r}
par(mfrow=c(2,2))
plot(density(grab_tp_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Toa Payoh")
plot(density(grab_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```
## 3.8 Findings
Again, fixed method is better in identifying patterns

#4 NKDE
```{r}
  tm_shape(roads_in_singapore)+tm_lines()+tm_shape(object_sp)+tm_dots()
```




## 4.1 Checking geom type for streets
```{r}
#st_geometry_type(lines)
```
## 4.2 Checking if lines are of linestring geom type
```{r}
#all_linestring <- all(st_geometry_type(lines) == "LINESTRING")

#print(all_linestring)
```

## 4.2 Lixelizing the streets
```{r}

#lines_sf <- st_as_sf(lines)
#lixels <- lixelize_lines(lines_sf,750,mindist=375)
```

## 4.3 Snapping
```{r}
#samples <-lines_center(lixels)
```

## No time to render code from here, hence commented!
## 4.4 Calculating densities
```{r}
#densities<-nkde(network,events=sf_object[1:100,],w=rep(1,nrow(sf_object)),samples=samples,
#                kernel_name = "quartic",bw=300,div="bw",method="simple",digits=1,tol=1,grid_shape = #c(1,1),max_depth=8,agg=5 ##agg events within 5m radius (faster calculation)
#                ,sparse=TRUE,verbose=FALSE)
```

## 4.5 Rescaling
```{r}
#samples$density <- densities
#lixels$density <- densities

#samples$density <- samples$density*1000
#lixels$density <- lixels$density*1000

```

## Plotting
```{r}
#tm_shape(lixels)+
#  tm_lines(col="density")+
#tm_shape(sf_object)+
#  tm_dots()
```

# 5 Improvements
Should better know how to make processing faster. Using a small sample, even smaller den grab1 and even smaller den the roads data, so that when time comes to render / build, it would be much faster. Right now my line of code can take 30 mins or more to even build 